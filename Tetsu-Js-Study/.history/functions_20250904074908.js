// ② functions.js
// 👉 関数まわりを集中管理

// 含める機能：

// 関数

// 引数

// 戻り値

// アロー関数

// コールバック関数


// =======================================
// JavaScriptの基本：関数（function）の使い方
// =======================================

// 1. 通常の関数の定義と引数
function introduce(name, job) {
    console.log("私は " + name + " です。"); // name = "哲也"
    console.log(job + " です。");           // job = "プログラマー"
}

// 関数の呼び出し（値を引数として渡す）
introduce("哲也", "プログラマー");

// 👉 補足説明
console.log("👉 上記で関数名 introduce (第一引数, 第二引数) を実行");
console.log("   - 一つ目の引数 '哲也' が name に渡る（第一引数、今回の値: 哲也）");
console.log("   - 二つ目の引数 'プログラマー' が job に渡る（第二引数、今回の値: プログラマー）");
console.log("👉 関数は呼び出さないと処理は実行されない。上記関数名 introduce で実行したので、処理が実行された");

// 2. 関数式（無名関数）の定義
const introduce2 = function (name, job) {
    console.log("私は " + name + " です。"); // name = "tetsuya"
    console.log(job + " です。");           // job = "コーダー"
};

// 関数式の呼び出し
introduce2("tetsuya", "コーダー");

// 👉 補足説明
console.log("👉 上記で関数名 introduce2 (第一引数, 第二引数) を実行");
console.log("   - 一つ目の引数 'tetsuya' が name に渡る（第一引数、今回の値: tetsuya）");
console.log("   - 二つ目の引数 'コーダー' が job に渡る（第二引数、今回の値: コーダー）");
console.log("👉 関数は呼び出さないと処理は実行されない。上記関数名 introduce2 で実行したので、処理が実行された");

// =======================================
// 3. 関数と関数式の違い・メリット・デメリット（まとめ）
// =======================================


// 【関数（function宣言）の特徴】
// ✅ 名前をつけて定義できる → コードが読みやすい
// ✅ 巻き上げ（ホイスティング）されるので、定義より前でも呼び出せる
// ❌ 変数に代入できないので柔軟性は低め

// 【関数式（無名関数）の特徴】
// ✅ 関数を変数に代入できる → 他の関数に渡したりできる
// ✅ 必要なタイミングで作れるので柔軟性が高い
// ❌ 巻き上げされないので、定義より前に呼び出すとエラーになる

// 【まとめ】
// 👉 基本的な処理は function で定義することが多い
// 👉 関数を値として扱いたいときや一時的に使うときは 関数式 を使う









// =======================================
// 今回の設定: 2025年8月28日（夜21時で動作確認）
// =======================================

// 💡 new Date() は「現在の日時」を生成するオブジェクト
//   例: Thu Aug 28 2025 21:00:00 GMT+0900 (Japan Standard Time)
//
// 💡 オブジェクトとメソッドの違い
// - オブジェクト: データそのもの（例: new Date() = 現在日時のかたまり）
// - メソッド: オブジェクトに付属する関数（例: .getHours(), .getMonth()）
//   → オブジェクトから「特定の情報」を厳選して取り出す処理
//
// 💡 値を関数に渡すイメージ（＝「中身を箱に入れる仕組み」）
// - 例: const season = getSeason(currentMonth) と書くと、
//        currentMonth の値（8）が function getSeason の括弧の中の month に入る
//   → 同じ関数名の括弧の中で値が受け渡され、関数内で処理される
//
// 💡 戻り値とは？
// - 関数の「処理結果を外に出す値」のこと
// - getDarkModeStatus(...) の場合 → "dark" または "light"
// - getSeason(...) の場合 → "春" / "夏" / "秋" / "冬"
// - この戻り値は呼び出し元の変数（mode や season）に格納される



// =======================================
// 記述順と実行順の対応図（背景色判定・季節判定共通）
// =======================================

// 🟢 記述順（コード上の順序）
// 1️⃣ 関数定義（function getDarkModeStatus / getSeason）
// 2️⃣ 変数定義（currentMonth / mode / season）
// 3️⃣ if 文で判定（mode や season を使って処理）
//
// 🟢 実行順（処理される順序）
// 1️⃣ 変数に日時を取得して代入（new Date(), .getHours(), .getMonth()+1）
//             ↓
// 2️⃣ 関数を呼び出す（getDarkModeStatus(...), getSeason(...)）
//             ↓
// 3️⃣ 関数内の if 文で判定処理
//             ↓
// 4️⃣ 判定結果（戻り値）を変数に代入（mode / season）
//             ↓
// 5️⃣ 変数を利用して処理や出力
//    - 背景色変更
//    - console.log 出力



// =======================================
// 🟢 背景色変更（ダークモード判定）
// =======================================

// 3️⃣ 関数を呼び出すときに使う関数を定義
function getDarkModeStatus(time) {
    // 4️⃣ 関数内の if 文で判定処理（time が 20 より大きいかどうか）
    if (time > 20) {
        return "dark"; // ← 戻り値（関数の外に出す値）
    } else {
        return "light"; // ← 戻り値（関数の外に出す値）
    }
}

// 1️⃣ 変数を呼び出す（mode を準備）
// 2️⃣ new Date() で日時を取得し、.getHours() で時間を取り出す
// 3️⃣ getDarkModeStatus(...) を呼び出す
const mode = getDarkModeStatus(new Date().getHours()); 
// 5️⃣ 戻り値 "dark" または "light" が変数 mode に格納される

// 6️⃣ 変数 mode を利用して背景色を変更
if (mode === "dark") {
    document.body.style.backgroundColor = "#000";
} else {
    document.body.style.backgroundColor = "#fff";
}

// 6️⃣ 結果を出力
console.log(`2️⃣ 現在のモード: ${mode} （今回の設定の2025年8月28日より dark）`);





// =======================================
// 🟢 季節判定（引数・戻り値付き）
// =======================================

// 3️⃣ 関数を呼び出すときに使う関数を定義
function getSeason(month) {
    // 4️⃣ 関数内の if 文で判定処理（月の範囲ごとに季節を判定）
    if (month >= 3 && month <= 5) {
        return "春"; // ← 戻り値（関数の外に出す値）
    } else if (month >= 6 && month <= 8) {
        return "夏"; // ← 戻り値（関数の外に出す値）
    } else if (month >= 9 && month <= 11) {
        return "秋"; // ← 戻り値（関数の外に出す値）
    } else {
        return "冬"; // ← 戻り値（関数の外に出す値）
    }
}

// 1️⃣ 変数を呼び出す（currentMonth, season を準備）
// 2️⃣ new Date() で日時を取得し、.getMonth() で月を取り出し、+1 で整形
const currentMonth = new Date().getMonth() + 1;

// 3️⃣ getSeason(currentMonth) を呼び出す
const season = getSeason(currentMonth); 
// 5️⃣ 戻り値 "春" / "夏" / "秋" / "冬" が変数 season に格納される

// 6️⃣ 変数 season を利用して結果を出力
console.log(`4️⃣ 現在の月は ${currentMonth} 月です （今回の設定の2025年8月28日より 8）`);
console.log(`4️⃣ 🌟 なので、季節は ${season} です！ （今回の設定の2025年8月28日より 夏）`);



// =======================================
// まとめ（記述順と実行順）
// =======================================
// 🟢 共通する作業の流れ
// 記述順（コード上）: function → 変数 → if文
// 実行順（処理される順序）: 
// 1️⃣ 変数取得 → 2️⃣ 関数呼び出し → 3️⃣ 関数内 if 判定 → 
// 4️⃣ 戻り値を変数に代入 → 5️⃣ 変数を利用して処理・表示










// 宇宙一わかりやすいJS
// https://youtu.be/ZE484EEuQ8k?si=qE-_dh3BZNDctbmq
// コールバック関数の仕組み解説（1: 基本例）
// =======================================
// 🟢 このコードの目的
// 「骨組み関数の中での追加処理」と「コールバック関数の中での追加処理」の違いを理解する
// =======================================

console.log("↓↓↓ a = 骨組み関数（固定の骨組み）、b = コールバック引数（a に渡される）、c = コールバック関数（差し込める処理、b が指すもの） ↓↓↓");

// =======================================
// 🚩STEP2: 骨組み関数定義 a（呼び出される側、骨組み部分）
// =======================================
function a(b) { // a = 骨組み関数, b = コールバック引数（ここに c が渡される）
    // 【説明1】
    // 呼び出し側に a(c); と呼び出されたとき、
    // 骨組み関数 a(b) の コールバック引数 b に「コールバック関数 c」が渡される
    // つまり b = c となる（b は c の別名になる）
    console.log("【1】メイン処理（a の骨組み部分）：必ず実行される固定の動作");

    // 【説明2】
    // 骨組み関数の中でも「追加処理」を書ける
    // これは必ず実行される（差し替えできない固定処理）
    console.log("【2】骨組み関数の追加処理（a 内）：毎回必ず実行される");

    // 【説明3】
    // コールバック引数 b は コールバック関数 c の「別名」になっている
    // 今回は「メイン処理がすべて終わったあと」にコールバックを呼び出す
    // 💡 コールバック関数は「最後に呼ぶ」こともできるし、
    //    必要に応じて「メイン処理の途中で呼ぶ」ことも可能（柔軟に配置できるのが特徴）
    console.log("👉 最後に骨組み関数の中で コールバック引数 b を使って 、 コールバック関数 c() を呼び出す（b = c のため b() が c() を実行）");

    // 📝 骨組み関数 a の役割：
    // a は「骨組み（テンプレート）の処理」を持つ関数
    // 「必ず実行される固定の処理」と「差し込むコールバックの呼び出し」を行うだけ
    // 自分の中で c が何をするか（引数を必要とするかどうか）は知らない／知らなくていい
    b();  // ✅ 骨組み関数 a の中で、コールバック引数 b を実行する（b = c のため、実際には c() が呼ばれる）
}

// =======================================
// 🚩STEP3: コールバック関数 c（差し込まれる処理、呼び出し側 a(c) の引数）
// =======================================
function c() { // c = コールバック関数
    // 【説明4】
    // 呼び出し側が自由に決められる処理
    console.log("【3】コールバック処理（c の内容）：差し込まれた具体的な動作");

    // 【説明5】
    // さらに追加処理も可能
    console.log("【4】コールバック処理の追加（c の内容）：自由に差し替えられるアクション");

    // 📝 コールバック関数 c の役割：
    // c は「呼び出し側が自由に定義できる処理」
    // 今回の c は引数を必要としないので、b() のまま呼び出しても問題なし
    // もし c が引数を受け取る設計なら、b(値) のように渡すことも可能
}

// =======================================
// 🚩STEP1: 呼び出し（実行開始）
// =======================================
a(c); // a = 骨組み関数 に c = コールバック関数 を渡す（b = c） 

// =======================================
// 🚩 処理の流れまとめ（矢印付き）
// =======================================
// 呼び出し: a(c) 🚩STEP1
//       ↓
// b = c   ← a(c) = a(b) よって b は c を指す（b = c） 🚩STEP2
//       ↓
// 【1】メイン処理 a が実行（固定の骨組み部分）
//       ↓
// b() が実行される → c() が呼ばれる（b = c のため） 🚩STEP3
//       ↓
// 【3】コールバック処理 c の中身（差し込み自由）
// 【4】コールバック処理 c の追加部分（差し替え可能）
//       ↓
// 【2】骨組み関数 a の追加処理（固定で必ず実行される）
//       ↓
// 完了！ 🎉




// コールバック関数の代わりに「ただの変数」を渡した場合の比較
// =======================================
// 🟡 このコードの目的
// 関数ではなく数字などの固定値を渡すとどうなるかを確認する
// =======================================

console.log("↓↓↓ f = 骨組み関数（固定の骨組み）、g = 引数、i = 数字（固定の値） ↓↓↓");

// =======================================
// 🚩STEP2: 骨組み関数定義 f（呼び出される側）
// =======================================
function f(g) {
    console.log("【1】メイン処理：必ず実行される基本の動作（骨組み部分）");

    console.log("【2】骨組み関数の追加処理：毎回必ず実行される（まとめや後片付けのイメージ）");

    // 関数ではなく変数が渡ってきた場合の処理
    console.log("👉 今回はコールバック関数が無いので、値をそのまま表示するよ！");
    console.log("【3】渡された値 g =", g);
}

// =======================================
// 🚩STEP3: 呼び出し
// =======================================
let i = 42; // ただの数字（変数）
f(i); // f に「数字」を渡す









// if文 vs コールバック関数 解説（シンプル比較版）
// =======================================
// 🟢 このコードの目的
// 「if文は処理が関数の中で固定」されているのに対して、
// 「コールバック関数は処理を外から差し替え可能」だと理解する
// =======================================

console.log("↓↓↓ if文版（固定処理）とコールバック版（差し替え可能処理）の比較 ↓↓↓");


// =======================================
// 🚩STEP1: if文版関数の定義（処理が固定）
// =======================================
function fixedJudgeFunction(num) { // num = 数字の入力
    // 【説明】
    // この関数の中には「5より大きいかどうか判定する」というルールが
    // 最初から固定で書かれている（差し替え不可）

    // 🚩補足：
    // 下の呼び出し例で fixedJudgeFunction(10) と実行すると、
    // 引数 num には 10 が入る。
    // だから今回は「10 > 5」を判定することになる。
    if (num > 5) {
        console.log("if文 → 大きい（今回は num が 5 より大きいから）");
    } else {
        console.log("if文 → 小さい");
    }
}



// =======================================
// 🚩STEP2: 骨組み関数（メインの流れだけ決める関数 = 高階関数）
// =======================================
function skeletonFunction(num, actionFunction) { 
    // num = 数字, actionFunction = 外から渡す処理関数

    // 【説明】
    // skeletonFunction は 呼び出し側から「数字を受け取って誰かに渡す」役だけをする。
    // 具体的に「どう判定するか」「どう計算するか」は知らない。
    // その部分は外から来る actionFunction に任せる。
    
    // 例：呼び出し側で skeletonFunction(10, judgeFunction) とすると
    // num（引数の左側） には 10、actionFunction（引数の右側） には judgeFunction が入る。
    // つまり skeletonFunction 内で書かれている コールバック引数 actionFunction(num) は、
    // 第一引数 num = 10 、第二引数 actionFunction = judgeFunction によって
    // → judgeFunction(10) に置き換わる。
    // だから実際には judgeFunction(10) が実行される。

    actionFunction(num);  
    // ✅ 骨組み関数 skeletonFunction の中で、コールバック引数 actionFunction を実行する
    // （actionFunction = judgeFunction のため、実際には judgeFunction(num) が呼ばれる）
}


// ◆◆◆骨組み関数のフロー
// 骨組み関数 skeletonFunction(num, actionFunction)

// 呼び出し側で skeletonFunction(10, judgeFunction) を実行
// ① 第一引数 num = 10
// ② 第二引数 actionFunction = judgeFunction

// 骨組み関数内で actionFunction(num) を実行
// → これは実際には judgeFunction(10) に置き換えられる

// 結果：judgeFunction(10) が実行される

    


// =======================================
// 🚩STEP3: 具体的な処理関数（コールバック関数）
// =======================================

// 【例1】判定する関数
function judgeFunction(n) {
    // n は数字（ここでは 10 や 3 が渡される）

    // 例：skeletonFunction(10, judgeFunction) とすると
    // n には 10 が入るので「10 > 5」を判定することになる。
    if (n > 5) {
        console.log("判定関数 → 大きい！（今回は n が 5 より大きいから）");
    } else {
        console.log("判定関数 → 小さい！");
    }
}



// 【例2】計算する関数
function doubleFunction(n) {
    // 例：skeletonFunction(5, doubleFunction) とすると
    // n には 5 が入る。
    // だから「5 を 2倍して 10」が出力される。
    console.log("計算関数 → 2倍 =", n * 2);
}


// =======================================
// 🚩STEP4: 呼び出し例（比較テスト）
// =======================================
// 💡 ポイント
// - if文版は「5より大きいかどうか判定」しかできない
// - コールバック版は「判定」や「2倍」など外から自由に差し替え可能
// =======================================

console.log("=== 入力値 10 の場合 ===");
fixedJudgeFunction(10);                     // if文版（固定ルール）
skeletonFunction(10, judgeFunction);       // コールバック版（判定関数）

console.log("=== 入力値 3 の場合 ===");
fixedJudgeFunction(3);                      // if文版（固定ルール）
skeletonFunction(3, judgeFunction);        // コールバック版（判定関数）

console.log("=== 入力値 5 の場合 ===");
fixedJudgeFunction(5);                      // if文版（固定ルール）
skeletonFunction(5, doubleFunction);       // コールバック版（計算関数）

// =======================================
// 🚩STEP5: 処理の流れまとめ（出力結果）
// =======================================
//
// === 入力値 10 の場合 ===
// if文 → 大きい
// コールバック → 大きい
//
// === 入力値 3 の場合 ===
// if文 → 小さい
// コールバック → 小さい
//
// === 入力値 5 の場合 ===
// if文 → 小さい
// コールバック → 2倍 = 10
//
// =======================================
// 📝 違いまとめ
// - if文版（fixedJudgeFunction）：ルールが固定で差し替え不可
// - コールバック版（skeletonFunction + 判定/計算関数）：同じ骨組みでも外から処理を差し替え可能
// =======================================


















// =======================================
// 🟢 アロー関数による自己紹介（戻り値なし）
// =======================================

// 💡 アロー関数とは？
// - function() を () => に置き換えてシンプルに書ける関数
// - 戻り値がない場合は return は不要
// - 引数を渡すと関数内でその値が使える

// =======================================
// 🟢 記述順と実行順の対応図（introducePerson）
// =======================================

// 記述順（コード上の順序）: function 定義 → 呼び出し → console.log
// 実行順（処理される順序）:
// 1️⃣ 呼び出し元で引数を準備
//             ↓
// 2️⃣ 関数を呼び出す（introducePerson(...)）
//             ↓
// 3️⃣ 関数内で処理（console.log による出力）
//             ↓
// 4️⃣ 戻り値はなし（関数内で直接処理を実行）
//             ↓
// 5️⃣ 呼び出し元では処理結果を受け取らず、出力は画面やコンソールに反映

// =======================================
// 🟢 関数定義
// =======================================
const introducePerson = (personName, personJob) => {
    // 2️⃣ 引数 personName を使ってコンソールに出力
    // 💡 戻り値はなし → 関数内で処理した内容を画面やコンソールに直接出力
    console.log(`私は${personName}です。`); // (今回の値: "aya")

    // 3️⃣ 引数 personJob を使ってコンソールに出力
    console.log(`${personJob}です。`); // (今回の値: "アドバイザー")
};

// =======================================
// 🟢 関数呼び出し
// =======================================

// 4️⃣ 引数を渡して関数を呼び出す
introducePerson("aya", "アドバイザー"); 
// 💡 実行の流れ:
// 引数 "aya", "アドバイザー" が関数に渡され → 関数内 console.log が順に実行され → コンソールに出力される

// 出力結果:
// 私はayaです。 (今回の値: "aya")
// アドバイザーです。 (今回の値: "アドバイザー")








//qittaより
// =======================================
// 🟢 面積計算（アロー関数・戻り値あり）
// =======================================

// 💡 アロー関数とは？
// - function() を () => に置き換えてコードをシンプルに書く
// - 戻り値は return で関数の外に返される
// - 呼び出した変数に格納して利用可能

// =======================================
// 🟢 記述順と実行順の対応図（calculateArea）
// =======================================

// 記述順（コード上の順序）: function 定義 → 呼び出し → 戻り値利用
// 実行順（処理される順序）:
// 1️⃣ 呼び出し元で引数を準備
//             ↓
// 2️⃣ 関数を呼び出す（calculateArea(...)）
//             ↓
// 3️⃣ 関数内で計算処理（height * width）
//             ↓
// 4️⃣ 戻り値を呼び出し元に返す
//             ↓
// 5️⃣ 呼び出し元で戻り値を受け取り console.log などで利用

// =======================================
// 🟢 関数定義
// =======================================
const calculateArea = (height, width) => {
    // 2️⃣ 関数内の計算処理
    // 💡 引数 height と width を掛け算して戻り値 return
    // 💡 戻り値は関数の外に出され、呼び出した変数に格納される
    return height * width; // (今回の値例: height=12, width=5 → 戻り値=60)
};

// =======================================
// 🟢 関数呼び出しと戻り値の利用
// =======================================

// 3️⃣ 引数を渡して呼び出す
console.log(`3️⃣ calculateArea(12, 5) の戻り値: ${calculateArea(12, 5)} （今回の値: 60）`);
// 💡 実行の流れ:
// calculateArea(12,5) が呼ばれ → 関数内で 12*5 が計算され → 戻り値 60 が返る → console.log で出力

// 4️⃣ 戻り値を変数に格納して利用
const areaResult = calculateArea(120, 50); // 戻り値 6000 が areaResult に格納される

// 5️⃣ 変数を利用して出力
console.log(`5️⃣ 変数 areaResult に格納された値: ${areaResult} （今回の値: 6000）`);
// 💡 戻り値 6000 が変数 areaResult に格納され → 画面や他の処理で利用可能







    // =======================================
// 戻り値の基本例（サムライエンジニアより）
// =======================================

// 🟢 記述順と実行順の対応図
// 記述順（コード上の順序）: function → 呼び出し → console.log
// 実行順（処理される順序）:
// 1️⃣ 呼び出し元で引数を準備
//             ↓
// 2️⃣ 関数を呼び出す（hello(...)）
//             ↓
// 3️⃣ 関数内で処理（引数を利用して文字列結合）
//             ↓
// 4️⃣ 戻り値が返る
//             ↓
// 5️⃣ 呼び出し元で戻り値を受け取り console.log で出力

// =======================================
// 🟢 関数定義
// =======================================
function hello(name) {
    //(2) 関数 hello を定義。引数 name に呼び出し元の値が渡される
    //     今回は "サムライエンジニア太郎" が代入される

    return "こんにちは、" + name + "さん"; 
    //(3) 関数の実行内容 = 戻り値
    //    引数の値を使って文字列を作り、関数の外に返す
}

// =======================================
// 🟢 呼び出し元（変数や値の準備と利用）
// =======================================
console.log(
    "ここのconsoleがhelloの呼び出し元。上記 hello の name に値が渡って return で hello がここに戻ってくる: " 
    + hello("サムライエンジニア太郎")
);
// (1) 呼び出し元で引数に "サムライエンジニア太郎" を設定
// (4) 戻り値 "こんにちは、サムライエンジニア太郎さん" が console に出力される








// =======================================
// ① 戻り値なしの関数（表示だけするタイプ）
// =======================================
function greet(name) {
  if (name === "てつや") {
    console.log("やあ！今日も元気だね、" + name + "さん！");
  } else {
    console.log("こんにちは！" + name + "さん！");
  }
}

//※※↓↓ 上記の関数 greet 内に return がないため
//    関数の外で値を受け取ろうとしても「undefined」になる。
//    （表示だけして、値は返していないから）

// 呼び出してみよう（これは画面に表示するだけ）
greet("てつや");  // → やあ！今日も元気だね、てつやさん！
greet("ゆうき");  // → こんにちは！ゆうきさん！

// 関数の戻り値を変数に入れようとしても・・・
let msg = greet("てつや");
console.log(msg);  // → undefined （値が返ってこないから）



// =======================================
// ② 戻り値ありの関数（答えを返すタイプ）
// =======================================
function judgeNumber(number) {
  if (number > 5) {
    return "5より大きい";
  } else {
    return "5以下";
  }
}

// 呼び出してみよう（これは「答え」を返してくれる）
let result1 = judgeNumber(10);
console.log(result1);  // → 5より大きい

let result2 = judgeNumber(3);
console.log(result2);  // → 5以下





// 宇宙一わかりやすいJS
// https://youtu.be/ZE484EEuQ8k?si=qE-_dh3BZNDctbmq
//戻り値その１<!--1:31:00～-->


// ===================================
// 🚀 戻り値チェックプログラム（アロー関数の動きがわかる版）
// ===================================

//Q.実行したら戻り値7777を返す関数"hyperDrive"を作成しなさい。

// --------------------------------------------------
// アロー関数 hyperDrive を定義
// --------------------------------------------------
// アロー関数とは、function を使わずに短く書ける関数の形
// () の中に引数、{} の中に実行する処理を書く
// 今回は、実行すると数値 7777 を返すだけのシンプルな関数
console.log("↓↓↓ === アロー関数 hyperDrive を定義する。実行すると常に戻り値 7777 を返す。 ===");
const hyperDrive = () => {
  return 7777; 
  // return は「この値を関数の外に渡す」命令
  // この場合、関数を呼び出すと必ず 7777 が戻る
};


console.log("↓↓↓ === 関数実行スタート ===");

// --------------------------------------------------
// ↓↓↓ アロー関数 hyperDrive を呼び出し、その戻り値を定数 resultValue に代入する
// --------------------------------------------------
console.log("↓↓↓ const resultValue = hyperDrive(); "
    + "で 定数 resultValue を定義して、関数 hyperDrive を実行する。"
    + "関数名 hyperDrive の後ろに () をつけると、"
    + "関数 hyperDrive が実行され、戻り値 7777 が resultValue に入る。");

const resultValue = hyperDrive(); 
// 関数名 hyperDrive の後ろに () をつけると、関数 hyperDrive が実行され、戻り値 7777 が resultValue に入る
// ここで resultValue に入っているのは関数ではなく「数値 7777」
// そのため resultValue は「参照」しかできず、関数のように呼び出すことはできない
// もし resultValue(); とすると「数値を関数として呼び出そうとした」ことになりエラーになる
// 関数として呼び出せるのは hyperDrive() のように、関数そのものに () をつけた場合だけ
// 定数 resultValue の中に格納された アロー関数 hyperDrive の戻り値 7777 を表示する

console.log(`${resultValue} ← この$波括弧resultValue は、
    定数 resultValue を参照（変数に入っている値をそのまま使う）し、
    定数 resultValue に格納されたアロー関数 hyperDrive の戻り値 7777 を表示している。`);


// --------------------------------------------------
// 関数名そのものを直接呼び出す例
// --------------------------------------------------
console.log(`${hyperDrive()} ← 波括弧 hyperDrive() で 
アロー関数 hyperDrive を直接呼び出した。`);

// ここでは hyperDrive() を直接実行しているため、処理が走り、7777 が返る
// この形が「関数を実行する」という正しい呼び出し方

// resultValue2
const resultValue2 = 8888;
console.log(`${resultValue2} ← 波括弧 resultValue2 で 
    定数 resultValue2 を参照（変数に入っている値をそのまま使う）し、
    その値 8888 を表示している。`);


console.log("=== 関数実行おわり ===");

/*
【動作シミュレーション表】

| 呼び出し方法     | 戻り値   | 出力例                          |
|------------------|---------|----------------------------------|
| hyperDrive()     | 7777    | hyperDrive の戻り値 → 7777       |
| hyperDrive(123)  | 7777    | hyperDrive の戻り値 → 7777       |
| hyperDrive(999)  | 7777    | hyperDrive の戻り値 → 7777       |

【ポイント】
- アロー関数はシンプルに書ける関数の形
- return した時点で関数は終了し、その値が外に渡る
- 引数を渡しても今回の関数は使わないので、何を渡しても同じ結果になる
- resultValue は「数値」なので () を付けて呼び出すことはできない
  → resultValue(); はエラーになる
*/

/*
【「呼び出す」と「参照する」の違い整理表】

| 用語        | 意味                                               | 例            | 結果         |
|-------------|----------------------------------------------------|---------------|--------------|
| 呼び出す    | 関数名の後ろに () を付けて、関数の処理を実行する    | hyperDrive()  | 7777         |
| 参照する    | 変数や定数に入っている値を () を付けずに使う        | resultValue   | 数値 7777    |
| 誤用例      | 戻り値（数値など）に () を付けて呼び出そうとする    | resultValue() | エラー       |

【補足】
- 関数は () を付けて「呼び出す」対象
- 数値や文字列などの戻り値は「参照」対象
- 戻り値が関数でない場合、() を付けるとエラーになる

【関数の実行 と 戻り値の扱い】
- 「関数を実行する」= 関数名 + () で関数内の処理を動かす（例：hyperDrive() → 7777）
- 戻り値は「関数の実行結果」であり、関数でなければ呼び出せない
- resultValue には数値 7777 が入っているので、() を付けて呼び出すことはできない
*/







// 宇宙一わかりやすいJS
// https://youtu.be/ZE484EEuQ8k?si=qE-_dh3BZNDctbmq
//==============================
// 🎯 戻り値の練習（引数の計算結果を返す）
//戻り値その１<!--1:32:15～-->
// Q. 引数 "inputValue" を受け取り、
// その値に 1.5 を掛けた結果を返す関数 "calculateBoost" を作成してください。

// ===================================
// ⚡ 倍率計算プログラム（アロー関数の練習版）
// ===================================

// Q. 受け取った数値を 1.5 倍して返すアロー関数 "calculateBoost" を作成しなさい。

// --------------------------------------------------
// アロー関数 calculateBoost を定義
// --------------------------------------------------
// アロー関数とは、function を書かずに短くシンプルに関数を定義できる書き方
// () の中に「引数（受け取る値）」を指定し、{} の中に「実行する処理」を書く
// 今回は、引数 inputValue を受け取り、それに 1.5 を掛け算して返す
console.log("↓↓↓ === アロー関数 calculateBoost を定義する。実行すると渡した数値の 1.5 倍を返す。 ===");

const calculateBoost = (inputValue) => {
  // inputValue：関数に渡される数値
  // 例） calculateBoost(50) とすると、inputValue には 50 が入る

  return inputValue * 1.5;
  // return は「関数の外に値を渡す」ための命令
  // ここでは「渡された値 × 1.5」を返している
  // 例） 50 を渡した場合、 50 × 1.5 = 75 が返る
};


// --------------------------------------------------
// 関数を呼び出して結果をコンソールに表示する
// --------------------------------------------------
console.log("↓↓↓ === 関数 calculateBoost を呼び出して、結果を確認する ===");

console.log(
  "計算結果: calculateBoost(50) の戻り値は → " + calculateBoost(50)
);
// 関数 calculateBoost を呼び出すときは、関数名の後ろに () を付ける
// () の中に「引数」を渡すと、その値が関数内で使われる
// 例） calculateBoost(50) → inputValue = 50
// 関数内で 50 × 1.5 の計算が行われ、結果 75 が return される
// その結果を文字列と結合してコンソールに表示している


// --------------------------------------------------
// 【動作シミュレーション表】
// --------------------------------------------------
/*
| 呼び出し方法              | inputValue | 計算内容      | 戻り値 | 出力例                                   |
|---------------------------|------------|---------------|--------|------------------------------------------|
| calculateBoost(50)        | 50         | 50 × 1.5      | 75     | 計算結果: calculateBoost(50) の戻り値は → 75 |
| calculateBoost(100)       | 100        | 100 × 1.5     | 150    | 計算結果: calculateBoost(100) の戻り値は → 150 |
| calculateBoost(0)         | 0          | 0 × 1.5       | 0      | 計算結果: calculateBoost(0) の戻り値は → 0   |

【ポイント】
- アロー関数は function より短く書ける関数の形
- 引数を () の中に書き、その値を使って処理できる
- return で返された値が「関数の戻り値」として外に渡る
- 呼び出すときは関数名 + () を使い、戻り値を参照できる
*/







// 宇宙一わかりやすいJS
// https://youtu.be/ZE484EEuQ8k?si=qE-_dh3BZNDctbmq
// <!--1:34:00～-->

// ===================================
// 🎲 抽選処理プログラム（引数と乱数の練習版）
// ===================================

// Q. 引数 "entryCode" を受け取り、成功率30%でその番号を返す関数 "winChance" を作成しなさい。
// 　→ 当選した場合：そのまま entryCode を戻す
// 　→ 外れた場合：0 を戻す
// --------------------------------------------------
// ヒント
// * if文を使って条件分岐する
// * Math.random() を用いて確率を判定する
//   Math.random() は 0 以上 1 未満のランダムな数を返す


// --------------------------------------------------
// 🎯 アロー関数 winChance を定義する
// --------------------------------------------------
// winChance（当選チャンス）という名前の関数を作成
// 引数 entryCode に抽選番号（例：200など）を渡す
// Math.random() を使って 30% の確率で「当選」判定を行う
// 当たったら entryCode を返し、外れたら 0 を返す
console.log("↓↓↓ === アロー関数 winChance を定義する。30% の確率で番号を返し、70% の確率で 0 を返す。 ===");

const winChance = (entryCode) => {
  // entryCode：抽選で使用する番号（例：200）
  // この値は「当選したときに返す番号」として利用される

  if (Math.random() <= 0.3) {
    // Math.random() は 0以上1未満のランダムな数を返す
    // 例）0.12, 0.58, 0.99 などがランダムに出てくる
    // もしその数値が 0.3 以下なら「当選」と判定する（確率30%）
    return entryCode; 
    // 当選した場合、渡された entryCode（例：200）をそのまま返す
  } else {
    // 0.3 より大きい数値が出た場合（確率70%）
    // この場合は「外れ」として 0 を返す
    return 0;
  }
};


// --------------------------------------------------
// 📢 関数を実行して抽選結果を表示する
// --------------------------------------------------
console.log("↓↓↓ === 関数 winChance を呼び出し、抽選結果を確認する ===");

console.log("抽選結果：番号200をエントリー → 戻り値は " + winChance(200));
// winChance(200) を呼び出す
// (1) entryCode に 200 が渡される
// (2) Math.random() の結果によって当選/外れが決まる
// 　　- 30% の確率 → 戻り値は 200
// 　　- 70% の確率 → 戻り値は 0
// (3) その戻り値を console.log で表示する


// --------------------------------------------------
// 【動作シミュレーション表】
// --------------------------------------------------
/*
| Math.random() の値 | 判定   | 戻り値 | 出力例                                |
|--------------------|--------|--------|---------------------------------------|
| 0.12               | 当選   | 200    | 抽選結果：番号200をエントリー → 戻り値は 200 |
| 0.58               | 外れ   | 0      | 抽選結果：番号200をエントリー → 戻り値は 0   |
| 0.99               | 外れ   | 0      | 抽選結果：番号200をエントリー → 戻り値は 0   |

【ポイント】
- Math.random() <= 0.3 なら「当選」
- それ以外は「外れ」
- 引数 entryCode を渡すと「当選した場合はその番号が戻り値になる」
- 外れた場合は常に 0 が戻り値になる
*/






// 宇宙一わかりやすいJS
// https://youtu.be/ZE484EEuQ8k?si=qE-_dh3BZNDctbmq
// <!--1::00～-->


// ===================================
// 📚 戻り値と return / undefined の関係
// ===================================
// Q. 関数の処理に return がある場合と無い場合で、
// 呼び出し元に何が返るのかを確認するプログラム


// --------------------------------------------------
// 戻り値その４ (return が無い場合 → undefined が返る)
// --------------------------------------------------
// ※※※ 関数の処理に return が無いと、呼び出し元には何も返らない。
// そのため、結果は自動的に undefined になる。
console.log("↓↓↓ === 関数 hello3 を定義する。return が無いため、呼び出し元には undefined が返る。 ===");

function hello3() {
  // 関数 hello3 の処理内容
  console.log("hello3はこんにちはがでますか？");
  // ↑ これは関数内でコンソールに文字を表示しているだけ
  // return が無いので、呼び出し元に渡す値は存在しない
}

let result3 = hello3(); 
// 関数 hello3 を呼び出し、結果を変数 result3 に代入する
// ただし hello3 には return が無いため、結果は undefined になる

console.log(result3); 
// result3 を参照して表示 → 中身は undefined
console.log("↑関数 hello3：関数に return が無い場合、呼び出し元は undefined になる");


// --------------------------------------------------
// return がある場合（呼び出し元に値が返る）
// --------------------------------------------------
// ※※※ 関数に return があると、呼び出し元にその値が返る。
console.log("↓↓↓ === 関数 hello4 を定義する。return があるため、呼び出し元に文字列が返る。 ===");

function hello4() {
  // 関数 hello4 の処理内容
  return "returnを使うとhello4はこんにちはがでます！"; 
  // return によって文字列を呼び出し元に返している
}

let result4 = hello4(); 
// 関数 hello4 を呼び出すと、return の結果（文字列）が返され、
// その値が result4 に代入される

console.log(result4); 
// result4 を参照して表示 → "returnを使うとhello4はこんにちはがでます！"
console.log("↑関数 hello4：関数に return がある場合、呼び出し元に値が返り、表示できる");


// --------------------------------------------------
// 【動作シミュレーション表】
// --------------------------------------------------
/*
| 関数名   | return の有無 | 戻り値       | 呼び出し元での結果          |
|----------|---------------|--------------|-----------------------------|
| hello3() | なし          | undefined    | result3 = undefined         |
| hello4() | あり          | 文字列       | result4 = "returnを使うと…" |

【ポイント】
- 関数の処理に return が無いと、自動的に undefined が返る
- return がある場合、その値が呼び出し元に返り、変数に代入して使える
- console.log() 内で return の結果を参照すると、返された値がそのまま表示される
*/


